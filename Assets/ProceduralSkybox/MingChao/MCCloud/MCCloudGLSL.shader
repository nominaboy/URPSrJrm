Shader "MingChao/MCCloudGLSL" {
    

    vertexshader {

            struct _29
            {
                float _m0;
                float _m1;
                float _m2;
                float _m3;
            };

            // uniform block
            layout(set = 1, binding = 0, std140) uniform _23_25
            {
                vec4 _m0[8];// _child0
                vec4 _m1[7];// _child1
                vec4 _m2[21];// _child2
            } _25;

            layout(set = 0, binding = 0, std140) uniform _30_32
            {
                vec4 _m0;
                uint _m1;
                uint _m2;
                int _m3;
                int _m4;
                ivec4 _m5;
                uvec4 _m6;
                _29 _m7;
            } _32;

            layout(location = 0) in vec4 positionOS;//_4 
            layout(location = 1) in vec3 tangentOS;//_7 
            layout(location = 2) in vec4 normalOS;//_8 
            layout(location = 4) in vec4 uvGroup;//_9 
            layout(location = 0) out vec4 _12;
            layout(location = 1) out vec4 _13;
            layout(location = 2) out vec4 _14;
            layout(location = 3) out vec4 _15;
            //vec4 _11;
            //vec4 _33;

            void _41(inout vec4 _42)
            {
                _42.y = -_42.y;
                _42.z = (2.0 * _42.z) - _42.w;
            }

            void main()
            {
                vec3 _64 = _25._m2[20u].xyz;//_child2[20]	-0.00119, -0.73807, 0.67472, -7.06947
                float _70 = _25._m2[19u].x;//_child2[19]	0.01, 0.96403, 0.03832, -3.28435
                float _76 = _25._m2[18u].x;//_child2[18]	0.50119, -0.26404, 0.02445, -2.18611
                float _80 = _25._m2[17u].x;//_child2[17]	80000.00, -0.0325, 0.99927, -7.11769
                float _84 = _25._m2[16u].x;//_child2[16]	35000.00, 0.96785, 0.03643, -3.06381
                float _88 = _25._m2[15u].x;//_child2[15]	1.00, -0.24943, 0.01118, -0.70666
                float _92 = _25._m2[14u].x;//_child2[14]	200000.00, 0.0431, 0.9987, -6.64735
                float _96 = _25._m2[13u].x;//_child2[13]	50000.00, 0.96623, -0.0347, 4.42091
                float _100 = _25._m2[9u].x;//_child2[9]	1.00, 279.41406, -8328.48535, -1.38222
                float _104 = _25._m2[8u].x;//_child2[8]	0.00, -279.41406, 8328.48535, -6.48927
                float _107 = _25._m2[7u].x;//_child2[7]	0.28, 0.00, 10.00, 0.00
                float _110 = _25._m2[6u].x;//_child2[6]	0.80, 279.41406, -8328.48535, 1.00
                float _114 = _25._m2[5u].x;//_child2[5]	0.10, 0.00, 0.00, 0.00
                float _118 = _25._m2[4u].x;//_child2[4]	0.00, -279.41406, 8328.48535, 0.50
                float _122 = _25._m2[3u].x;//_child2[3]	10000.00, 0.00, 10.00, 0.00
                float _125 = _25._m2[2u].x;//_child2[2]	0.50, 0.4322, 0.00, 0.98247
                float _128 = _25._m2[1u].x;//_child2[1]	0.00, 2.25233, 0.00, -0.18444
                float _131 = _25._m0[7u].x;//_child0[7]	0.00, 0.00, 10.00, 0.00
                vec3 _134 = _25._m0[5u].xyz;//_child0[5]	0.00, 0.00, 0.00, 0.00
                vec3 _138 = _25._m0[4u].xyz;//_child0[4]	352.35156, -279.41406, 8328.48535, 0.50
                //vec3 _147 = cross(cross(normalOS.xyz, tangentOS) * normalOS.www, normalOS.xyz) * normalOS.www;



                mat3 _165;
                _165[0u] = _25._m1[0u].xyz;//_child1[0] 4500.00, 0.00, 0.00, 0.00
                _165[1u] = _25._m1[1u].xyz;//_child1[1] 0.00, 4500.00, 0.00, 0.00
                _165[2u] = _25._m1[2u].xyz;//_child1[2]	0.00, 0.00, 4500.00, 0.00
                mat3 _164 = _165;
                //_child1[4]	0.00022, 0.00022, 0.00022, 1.00
                _164[0u] = _165[0u] * _25._m1[4u].xxx;// 4500 * 0.00022 = 1   ???
                _164[1u] *= _25._m1[4u].yyy;
                _164[2u] *= _25._m1[4u].zzz;
                //vec3 _200 = (_147.zzz * _164[2u]) + ((_147.yyy * _164[1u]) + (_147.xxx * _164[0u]));
                vec3 _201 = (normalOS.zzz * _164[2u]) + ((normalOS.yyy * _164[1u]) + (normalOS.xxx * _164[0u]));
                float _146 = normalOS.w * _25._m1[4u].w;




                vec4 _242;
                //_242.w = 1.0;

                //_child1[6]	1.00, 1.00, 1.00, 1.00
                //_child1[5]	0.00, 0.00, 0.00, 0.00
                vec3 _254 = (positionOS.xyz * _25._m1[6u].xyz) + _25._m1[5u].xyz;
                _242 = vec4(_254.x, _254.y, _254.z, 1.0);
                vec4 _257;
                //_257.w = 1.0;

                //_child1[0] 4500.00, 0.00, 0.00, 0.00
                //_child1[1] 0.00, 4500.00, 0.00, 0.00
                //_child1[2] 0.00, 0.00, 4500.00, 0.00
                //_child1[3] 97503.00, -114479.00, 0.00, 1.00
                //_child0[6] -352.35156, 279.41406, -8328.48535, 1.00
                vec3 _286 = (((_25._m1[0u].xyz * _242.xxx) + (_25._m1[1u].xyz * _242.yyy)) + (_25._m1[2u].xyz * _242.zzz)) + (_25._m1[3u].xyz + _25._m0[6u].xyz);
                _257 = vec4(_286.x, _286.y, _286.z, 1.0);
                vec4 _145 = _257;
                _145 = vec4(_257.xyz.x, _257.xyz.y, _257.xyz.z, _145.w); // positionWS

                float4 positionWS = float4(TransformObjectToWorld(positionOS.xyz), 1.0);
                float3 positionWS = TransformObjectToWorld(positionOS.xyz);




                // _child0[0]	1.28956, 0.32863, 0.00, -0.02691
                // _child0[1]	-0.18826, 2.25233, 0.00, -0.18444
                // _child0[2]	0.00058, 0.4322, 0.00, 0.98247
                // _child0[3]	0.00, 0.00, 10.00, 0.00
                vec4 _294 = _25._m0[3u] + ((_25._m0[2u] * _145.zzzz) + ((_25._m0[1u] * _145.yyyy) + (_25._m0[0u] * _145.xxxx)));// positionCS
                vec4 _143 = positionWS;//_145;
                vec4 _144 = vec4(0.0, 0.0, 0.0, 1.0);
                if (_131 > 0.0)
                {
                    positionWS/*vec3 _323*/ = positionWS/*_145.xyz*/ + (-_134);//_child0[5]	0.00, 0.00, 0.00, 0.00
                    float _331 = min(_138.z, min(FLT_MAX/*3.4028230607370965250836333559001e+38*/, _138.z + 65536.0));//_138.z = 8328
                    positionWS/*vec3 _330*/ = positionWS/*_323*/;
                    positionWS/*_330*/.z = positionWS/*_323*/.z + (_138.z + (-_331));//_138.z = 8328
                    float _351 = dot(_330, _330);
                    float _355 = inversesqrt(_351);
                    float _358 = _351 * _355;// |_330| ^ 3
                    vec4 _329;
                    if (_358 < _70)// < 0.01
                    {
                        _329 = vec4(0.0, 0.0, 0.0, 1.0);
                    }
                    else
                    {
                        vec3 _368 = positionWS/*_330*/ * vec3(_355);// normalize
                        float _373 = 1.0 + (-_100); //1 - 1
                        float _377 = step(_358, 6000000.0);
                        float _381 = mix(_107/*0.28*/ / 1000.0, _110/*0.80*/ / 1000.0, clamp((_358 + (-2000000.0)) / (-800000.0), 0.0, 1.0));
                        float _394 = max(_104/*0*/, 0.01) * _355;
                        float _400 = _394 * positionWS/*_330*/.z;
                        float _405 = 1.0 + (-_394);
                        float _409 = ((_405 * _405) * _405) * _358;
                        float _417 = _358 + (-_122/*10000*/);
                        float _422 = (_114/*0.1*/ * exp2(-max(-127.0, _381 * ((_331 + _400) + (-_138.z))))) / 1000.0;
                        float _440 = max(-127.0, _381 * (positionWS/*_330*/.z + (-_400)));
                        float _449 = (1.0 + (-exp2(-_440))) / _440;
                        float _457 = abs(_440);
                        float _460 = (_457 > 0.01) ? _449 : 0.693147182464599609375;
                        float _439 = _422 * _460;
                        float _469 = (dot(_64, _368) * 0.5) + 0.5;//_child2[20]	-0.00119, -0.73807, 0.67472, -7.06947  lightdir?
                        float _476 = (min(pow(exp((_469 * 37.51020050048828125) + (-37.51020050048828125)), 
                            mix(_125/*0.5*/, abs(dot(_368, vec3(0.0, 0.0, 1.0))) * _125/*0.5*/, _118/*0.00*/)), 1.0) * 
                            clamp((((_469 * _469) * _469) * _469) * _469, 0.0, 1.0)) * 
                            max(1.0 + (-clamp(exp2(-(_439 * _417)), 0.0, 1.0)), clamp((_409 + (-500000.0)) / 500000.0, 0.0, 1.0));
                        float _521 = max(clamp(exp2(-(_439 * _409)), 0.0, 1.0), _373);
                        float _530 = min(_521 * mix(1.0, 1.0 + (-min(0.80, _476)), clamp(_128, 0.0, 1.0)), 
                            max(0.0, 1.0 + (-((_377 * clamp((_358 + (-_84)) / ((_84 + _80) + (-_84)), 0.0, 1.0)) * _76))));
                        vec3 _607 = mix(mix(mix(_25._m2[10u].xyz, _25._m2[11u].xyz, vec3(pow(clamp((_358 + (-_96)) / (_92 + (-_96)), 0.0, 1.0), _88))), 
                            _25._m2[12u].xyz, vec3(_521)), _25._m2[0u].xyz * vec3(_128), vec3(clamp(_476 * _128, 0.0, 1.0))) * vec3(1.0 + (-_530));
                        vec4 _561;
                        _561 = vec4(_607.x, _607.y, _607.z, _561.w);
                        _561.w = _530;
                        _329 = _561;
                    }
                    _144 = mix(vec4(0.0, 0.0, 0.0, 1.0), _329, vec4(_131/*0*/));
                }
                vec4 _619[1];
                _619[0u] = vec4(0.0);
                _619[0u] = vec4(uvGroup.x, uvGroup.y, _619[0u].z, _619[0u].w);
                vec4 _628[1];
                _628[0u] = _619[0u];
                _628[0u] = vec4(_628[0u].x, _628[0u].y, uvGroup.z, uvGroup.w);
                //vec4 _637;
                //_637.w = 0.0;
                //_637 = vec4(_200.x, _200.y, _200.z, 0.0);

                /* Normal */
                vec4 _642;
                _642 = vec4(_201.x, _201.y, _201.z, _642.w);
                _642.w = _146;


                _143.w = _294.w;
                vec4 _142 = _294;
                //_11 = _637;
                _12 = _642;//normalWS
                _13 = _628[0u];//uvGroup
                _14 = _144;
                _15 = _143;//positionWS.xyz(original) + positionCS.w
                vec4 _658 = _142;
                _41(_658);
                _142 = _658;
                gl_Position = _142;
            }


    
    }

    /**************************************************************************************************************/




    /**************************************************************************************************************/



    /**************************************************************************************************************/


    fragmentShader {

        layout(early_fragment_tests) in;

        layout(constant_id = 4) const uint _2 = 0u;

        struct _31
        {
            float _m0;
            float _m1;
            float _m2;
            float _m3;
        };

        const float _683[4] = float[](-0.01171875, 0.00390625, 0.01171875, -0.00390625);

        layout(set = 1, binding = 1, std140) uniform _25_27
        {
            vec4 _m0[7];
            vec4 _m1[2];
            vec4 _m2[16];
            vec4 _m3[7];
        } _27;

        layout(set = 0, binding = 0, std140) uniform _32_34
        {
            vec4 _m0;
            uint _m1;
            uint _m2;
            int _m3;
            int _m4;
            ivec4 _m5;
            uvec4 _m6;
            _31 _m7;
        } _34;

        layout(set = 2, binding = 0) uniform sampler2D redMask;// _7
        layout(set = 2, binding = 1) uniform sampler2D NoiseMap;// _8
        layout(set = 2, binding = 2) uniform sampler2D cloudTex;// _9
        layout(set = 2, binding = 3) uniform sampler2D thunderTex;// _10

        layout(location = 0) in vec4 _13;//normalWS
        layout(location = 1) in vec4 uvGroup;//_14
        layout(location = 2) in vec4 _15;
        layout(location = 3) in vec4 _16;//positionWS.xyz(original) + positionCS.w
        layout(location = 0) out vec4 _18;
        float _700;
        uint _704;
        vec3 _709 = vec3(255.0);

        void main()
        {
            vec3 _705 = vec3(0.0);
            float _40 = _27._m0[5u].x;//0.00, 2.31685, 0.00, 0.00
            float _46 = _27._m0[4u].x;//0.00, 0.00, 0.00, 0.00
            float _50 = _27._m0[2u].x; // lod             0.00, 1.00, 1.00, 1.00
            float _53 = _27._m0[1u].x;//142.64896, -279.41406, 8328.48535, 0.50
            vec3 _61 = _16.xyz + (-_27._m0[0u].xyz);//-352.35156, 279.41406, -8328.48535, 0.00
            vec3 _70 = normalize(-_16.xyz);// -positionWS
            vec3 _76 = cross(_27._m2[10u].xyz, vec3(0.0, 0.0, 1.0));//-2.97717, -0.57143, 2.00, 0.00
            float _86 = length(_76);
            vec3 _85 = _76 / vec3(_86);//normal vector on xy-plane
            vec2 _95;
            _95.x = dot(_85, _70);
            _95.y = dot(cross(_85, _27._m2[10u].xyz), _70);

            vec2 _108 = clamp((vec2(1.0) + ((_95 * _27._m2[11u].xy/*0.00, 0.00, 0.00, 0.00*/) + 
                _27._m2[11u].zw)) * vec2(0.5), vec2(0.0), vec2(1.0));
            vec2 _126;
            _126.x = _108.x;
            _126.y = min(max(_108.y, _27._m2[12u].x), _27._m2[12u].y/*0.00, 0.00, 0.00, 0.00*/);
            vec4 _140 = texture(thunderTex, _126, _50);
            vec2 _145;
            _145.x = _140.y;//thunder mask 1
            _145.y = _140.w;//thunder mask 2
            vec2 _153;
            _153.x = _140.x;//thunder path 1
            _153.y = _140.z;//thunder path 2


            //_m3[2]	4.00, 0.50, 0.00, 1.00
            //_m2[2]	1.00, 1.00, 0.00, 2.00
            //_m2[4]	0.00, 1.00, 1.00, 0.00
            float _160 = ((fract((_53/*142.64896  _Time???*/ * _27._m3[2u].y) * 0.001) + _27._m3[2u].z) * _27._m2[2u].y) + _27._m2[4u].w;
            vec2 _177;
            _177.y = 0.0;
            _177.x = _160;

            vec2 _181 = vec2(-0.5) + uvGroup.zw;// -0.5 0.5
            float _187 = _160 * 6.28318500518798828125/*2PI*/;
            float _191 = cos(_187);
            float _194 = sin(_187);
            vec2 _197;
            _197.x = _191;
            _197.y = _194 * (-1.0);
            vec2 _204;
            _204.x = _194;
            _204.y = _191;
            vec2 _209;
            // 旋转矩阵变换
            _209.x = dot(_181, _197);
            _209.y = dot(_181, _204);
            //_m3[2]	4.00, 0.50, 0.00, 1.00
            vec2 _218 = mix(uvGroup.xy + _177, vec2(0.5) + _209, _27._m3[2u].ww) * _27._m3[1u].xy;//_27._m3[1u].xy = (1,1)
            // 两种不同映射插值？
            vec4 cloudTex = texture(cloudTex, _218, _50);// _233

            //_m2[15]	0.00, 0.00, 0.00, 0.00
            //_m2[3]	0.00, 0.00, 0.00, 0.00
            //_m3[2]	4.00, 0.50, 0.00, 1.00
            //_m2[13]	1.00, 0.00, 0.00, 0.00
            //_m3[0]	2.508, 2.9016, 3.00, 0.00
            //_m3[3]	1.00, 0.10, 0.60, 0.50
            //_m2[14]	0.00, 0.00, 0.00, 0.00
            // Thunder Calculation
            vec3 _238 = _27._m2[15u].zzz * ((((vec3(step(1.0 + (-(_27._m2[3u].y * _27._m3[2u].x)), dot(_27._m2[13u].xy, _145)) * 
                dot(_27._m2[13u].xy, _153)) * _27._m3[0u].xyz) * 
                vec3(clamp((cloudTex.x + (-_27._m3[3u].y)) / _27._m3[3u].w, 0.0, 1.0))) * _27._m2[14u].xyz) * _27._m2[3u].xxx);

            //_m2[6]	0.40278, 0.72345, 1.00, 1.00
            //_m2[9]	0.10866, 0.22145, 0.34201, 1.00
            vec3 _290 = _27._m2[6u].xyz * _27._m2[9u].xyz;//云的颜色
            float _300 = 1.0 + (-uvGroup.y);//vertexColor.y: 1为地平线，0为球顶
            float _306 = pow(_300, 0.3);// 地0 天1
            float _310 = (_300 <= 0.0) ? 0.0 : _306;
            //_m3[4]	1.00, 3.00, 0.30, 0.30
            float _317 = _310 * _27._m3[4u].x;
            //_m2[0]	0.00, 0.60, 0.885, 1.28
            float _322 = pow(cloudTex.x, max(_27._m2[0u].w, 0.5));//云亮部暗部
            float _329 = (cloudTex.x <= 0.0) ? 0.0 : _322;
            float _335 = _317 * _329;// 高度 * 亮暗

            //_m2[5]	1.00, 0.86888, 0.55996, 1.00
            vec3 _339 = mix(_290, _27._m2[5u].xyz, vec3(_335));//根据高度*亮暗，插值云朵颜色

            //_m2[8]	1.00, 0.73579, 0.19444, 1.00
            //_m0[6]	-0.00119, -0.73807, 0.67472, 1.00     lightDir
            vec3 _347 = _27._m2[8u].xyz * vec3(2.0);// color
            vec3 _355 = _27._m0[6u].xyz * vec3(-1.0);// lightDir
            float _361 = (1.0 + dot(_355, _70)) * 0.5; // LDotPosWS
            //_m3[4]	1.00, 3.00, 0.30, 0.30
            float _367 = pow(_361, _27._m3[4u].y);
            float _372 = (_361 <= 0.0) ? 0.0 : _367;
            //_m2[0]	0.00, 0.60, 0.885, 1.28
            vec3 _377 = _339 + (_347 * vec3(_335 * (_27._m2[0u].y * _372)));// ... + LDotPosWS * 高度 * 亮暗 * color

            //_m1[1]	0.38524, 0.52956, 0.70, 1.00
            //_m1[0]	0.00, 150000.00, 1.00, 0.00
            vec3 _389 = mix(mix(_377, _27._m1[1u].xyz, _27._m1[0u].zzz), _377, vec3(_317));// 高度lerp

            //_m2[1]	1.00, 0.50, 1.00, 1.00
            //_m2[7]	1.00, 1.00, 1.00, 1.00
            vec3 _402 = _389 + (_27._m2[1u].yyy * _27._m2[7u].xyz);// 云增亮？

            vec2 _412 = _70.xy / _70.zz;//positionWS作为NOISEMAP UV
            // _m3[4]	1.00, 3.00, 0.30, 0.30    白天晚上都不变
            // _m2[10]	-2.97717, -0.57143, 2.00, 0.00       白天晚上都不变
            float _419 = length(((texture(NoiseMap, _412 * _27._m3[4u].zz, _50).xy * _27._m3[4u].ww) + _412) + 
                (-(_27._m2[10u].xy / _27._m2[10u].zz)));
            //_m2[15]	0.00, 0.00, 0.00, 0.00
            float _418 = 1.0 + (-clamp(_419 / _27._m2[15u].x, 0.0, 1.0));
            float _452 = pow(_418, _27._m2[15u].y);
            float _457 = (_418 <= 0.0) ? 0.0 : _452;

            //_m2[15]	0.00, 0.00, 0.00, 0.00
            //_m2[3]	0.00, 0.00, 0.00, 0.00
            //_m2[2]	1.00, 1.00, 0.00, 2.00
            //_m2[14]	0.00, 0.00, 0.00, 0.00
            vec3 _462 = max(_402, vec3(_27._m2[15u].w * max(_457 * _27._m2[3u].x, _27._m2[2u].z)) * _27._m2[14u].xyz);

            float _480 = dot(_355, _13.xyz);//NDotL
            float _485 = pow(_480, 2.0);// 0 - 1
            float _488 = (_480 <= 0.0) ? 0.0 : _485;
            float _493 = pow(cloudTex.y, _27._m3[5u].x);//云边缘光
            float _499 = (cloudTex.y <= 0.0) ? 0.0 : _493;
            vec3 _505 = mix(_389, _462, vec3(_488 * _499));// NDOTL*CloudY  lerp两个颜色？
            //_m2[4]	0.00, 1.00, 1.00, 0.00
            vec3 _513 = _238 + (_505 * _27._m2[4u].yyy);//第一部分CloudX亮暗相关颜色 + 第二部分CloudY边缘相关颜色

            //_m2[3]	0.00, 0.00, 0.00, 0.00
            float _521 = abs(_27._m2[3u].x + (-0.01));
            vec3 _527 = mix(_505, _513, bvec3(_27._m2[3u].x >= 0.01));// = _505
            vec3 _537 = mix(_513, _527, bvec3(_521 > 0.0));// = _527
            float _545 = dot(_537, vec3(0.3, 0.59, 0.11));// Luminance
            vec3 _551;// Luminance
            _551.x = _545;
            _551.y = _545;
            _551.z = _545;

            //_m2[2]	1.00, 1.00, 0.00, 2.00
            //_m3[5]	2.00, 1.00, 0.00, 1.00
            float _558 = mix(min(max(_27._m2[2u].w + (-0.5), -0.5), 1.0), 1.0, _27._m3[5u].z);//1
            float _567 = 1.0 + (-_558);//0
            vec3 _584 = (max(mix(_537, _551, vec3(_40)), vec3(0.0)) * _15.www) + _15.xyz;
            vec4 _571;
            _571 = vec4(_584.x, _584.y, _584.z, _571.w);

            // finalColor透明度计算
            _571.w = clamp(((smoothstep(0.0, 200000.0, _61.z) * clamp(mix(cloudTex.w, mix(cloudTex.z * smoothstep(clamp(_567 + (-0.5), 0.0, 1.0), clamp(_567, 0.0, 1.0), 
                    texture(redMask, _218, _50).x), cloudTex.z, smoothstep(0.95, 1.0, _558)), smoothstep(-0.5, -0.3, _558)), 0.0, 1.0)) * _27._m2[1u].z) * 
                    clamp(smoothstep(0.0, 1.0, cloudTex.x + _27._m3[6u].y), 0.0, 1.0), 0.0, 1.0);

            vec4 _58 = _571;
            vec3 _645 = mix(_571.xyz, vec3(dot(_571.xyz, vec3(0.299, 0.587, 0.114))), vec3(_46));// 原始颜色 灰度 插值
            _58 = vec4(_645.x, _645.y, _645.z, _58.w);
            vec3 _656 = mix(_58.xyz, vec3(dot(_58.xyz, vec3(0.299, 0.587, 0.114))), vec3(_40));// 原始颜色 灰度 插值
            _58 = vec4(_656.x, _656.y, _656.z, _58.w);

            //_m0[3]	1.00, 1.00, 1.00, 1.00
            vec3 _664 = _58.xyz * _27._m0[3u].xyz;
            _58 = vec4(_664.x, _664.y, _664.z, _58.w);
            vec3 _671 = -min(-_58.xyz, vec3(0.0));
            _58 = vec4(_671.x, _671.y, _671.z, _58.w);
            _18 = _58;


            //Debug Code?
            if (_2 != 0u)
            {
                _700 = _683[((uint(gl_FragCoord.x) & 1u) << 1u) | (uint(gl_FragCoord.y) & 1u)];
                _704 = (_2 >> 0u) & 3u;
                switch (_704)
                {
                    case 1u:
                    {
                        _705 = vec3(_700 * 2.0);
                        _709 = vec3(15.0);
                        break;
                    }
                    case 2u:
                    {
                        _705 = vec3(_700);
                        _709 = vec3(31.0);
                        break;
                    }
                    case 3u:
                    {
                        _705 = vec3(_700, _700 * 0.5, _700);
                        _709 = vec3(31.0, 63.0, 31.0);
                        break;
                    }
                }
                vec3 _734 = _18.xyz + _705;
                _18 = vec4(_734.x, _734.y, _734.z, _18.w);
                vec3 _743 = round(_18.xyz * _709) / _709;
                _18 = vec4(_743.x, _743.y, _743.z, _18.w);
            }
        }

    
    
    }





}
